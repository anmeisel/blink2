{"ast":null,"code":"// ISO 639-1 codes of supported languages\nconst supported_language_codes = [\"ar\", \"cs\", \"da\", \"de\", \"en\", \"es\", \"fa\", \"fr\", \"gl\", \"it\", \"ko\", \"nl\", \"pl\", \"pt\", \"ro\", \"ru\", \"sv\", \"tr\", \"vi\"];\nconst stopwords = require(\"./stopwords/stopwords\");\nfunction extract(str, options = {\n  remove_digits: true,\n  return_changed_case: true\n}) {\n  if (!str) {\n    return [];\n  }\n  const return_changed_case = options.return_changed_case;\n  const return_chained_words = options.return_chained_words;\n  const remove_digits = options.remove_digits;\n  let _language = options.language || \"en\";\n  const _remove_duplicates = options.remove_duplicates || false;\n  const return_max_ngrams = options.return_max_ngrams;\n  _language = sanitize_language(_language);\n\n  //  strip any HTML and trim whitespace\n  const text = str.replace(/(<([^>]+)>)/gi, \"\").trim();\n  if (!text) {\n    return [];\n  } else {\n    const words = text.split(/\\s/);\n    const unchanged_words = [];\n    const low_words = [];\n    //  change the case of all the words\n    for (let x = 0; x < words.length; x++) {\n      let w = words[x].match(/https?:\\/\\/.*[\\r\\n]*/g) ? words[x] : words[x].replace(/\\.|,|;|!|\\?|\\(|\\)|:|\"|^'|'$|“|”|‘|’/g, \"\");\n      //  remove periods, question marks, exclamation points, commas, and semi-colons\n      //  if this is a short result, make sure it's not a single character or something 'odd'\n      if (w.length === 1) {\n        w = w.replace(/_|@|&|#/g, \"\");\n      }\n      //  if it's a number, remove it\n      const digits_match = w.match(/\\d/g);\n      if (remove_digits && digits_match && digits_match.length === w.length) {\n        w = \"\";\n      }\n      if (w.length > 0) {\n        low_words.push(w.toLowerCase());\n        unchanged_words.push(w);\n      }\n    }\n    let results = [];\n    const _stopwords = options.stopwords || getStopwords({\n      language: _language\n    });\n    let _last_result_word_index = 0;\n    let _start_result_word_index = 0;\n    let _unbroken_word_chain = false;\n    for (let y = 0; y < low_words.length; y++) {\n      if (_stopwords.indexOf(low_words[y]) < 0) {\n        if (_last_result_word_index !== y - 1) {\n          _start_result_word_index = y;\n          _unbroken_word_chain = false;\n        } else {\n          _unbroken_word_chain = true;\n        }\n        const result_word = return_changed_case && !unchanged_words[y].match(/https?:\\/\\/.*[\\r\\n]*/g) ? low_words[y] : unchanged_words[y];\n        if (return_max_ngrams && _unbroken_word_chain && !return_chained_words && return_max_ngrams > y - _start_result_word_index && _last_result_word_index === y - 1) {\n          const change_pos = results.length - 1 < 0 ? 0 : results.length - 1;\n          results[change_pos] = results[change_pos] ? results[change_pos] + \" \" + result_word : result_word;\n        } else if (return_chained_words && _last_result_word_index === y - 1) {\n          const change_pos = results.length - 1 < 0 ? 0 : results.length - 1;\n          results[change_pos] = results[change_pos] ? results[change_pos] + \" \" + result_word : result_word;\n        } else {\n          results.push(result_word);\n        }\n        _last_result_word_index = y;\n      } else {\n        _unbroken_word_chain = false;\n      }\n    }\n    if (_remove_duplicates) {\n      results = results.filter((v, i, a) => a.indexOf(v) === i);\n      ;\n    }\n    return results;\n  }\n}\nfunction getStopwords(options) {\n  options = options || {};\n  let _language = options.language || \"en\";\n  _language = sanitize_language(_language);\n  return stopwords[_language];\n}\n\n// Sanitize requested language\nfunction sanitize_language(requested_language) {\n  const error_message = \"Language must be one of [\" + supported_language_codes.join(\", \") + \"]\";\n  if (typeof requested_language !== \"string\") {\n    throw new Error(error_message);\n  }\n\n  // Fallback for old language option format\n  const _requested_language = requested_language.length === 2 ? requested_language : get_language_mapping(requested_language);\n  if (supported_language_codes.indexOf(_requested_language) < 0) {\n    throw new Error(error_message);\n  }\n  return _requested_language;\n}\n\n// Support old language option format by mapping to ISO 639-1 codes\nfunction get_language_mapping(requested_language) {\n  if (typeof requested_language !== \"string\") {\n    return \"\";\n  }\n  const mapping = {\n    arabic: \"ar\",\n    czech: \"cs\",\n    danish: \"da\",\n    dutch: \"nl\",\n    english: \"en\",\n    french: \"fr\",\n    galician: \"gl\",\n    german: \"de\",\n    italian: \"it\",\n    korean: \"ko\",\n    persian: \"fa\",\n    polish: \"pl\",\n    portuguese: \"pt\",\n    romanian: \"ro\",\n    russian: \"ru\",\n    spanish: \"es\",\n    swedish: \"sv\",\n    turkish: \"tr\",\n    vietnam: \"vt\"\n  };\n  return mapping[requested_language] || \"\";\n}\nmodule.exports = {\n  getStopwords,\n  extract,\n  supported_language_codes\n};","map":{"version":3,"names":["supported_language_codes","stopwords","require","extract","str","options","remove_digits","return_changed_case","return_chained_words","_language","language","_remove_duplicates","remove_duplicates","return_max_ngrams","sanitize_language","text","replace","trim","words","split","unchanged_words","low_words","x","length","w","match","digits_match","push","toLowerCase","results","_stopwords","getStopwords","_last_result_word_index","_start_result_word_index","_unbroken_word_chain","y","indexOf","result_word","change_pos","filter","v","i","a","requested_language","error_message","join","Error","_requested_language","get_language_mapping","mapping","arabic","czech","danish","dutch","english","french","galician","german","italian","korean","persian","polish","portuguese","romanian","russian","spanish","swedish","turkish","vietnam","module","exports"],"sources":["/Users/Tian/Documents/blink2/node_modules/keyword-extractor/lib/keyword_extractor.js"],"sourcesContent":["// ISO 639-1 codes of supported languages\nconst supported_language_codes = [\n  \"ar\",\n  \"cs\",\n  \"da\",\n  \"de\",\n  \"en\",\n  \"es\",\n  \"fa\",\n  \"fr\",\n  \"gl\",\n  \"it\",\n  \"ko\",\n  \"nl\",\n  \"pl\",\n  \"pt\",\n  \"ro\",\n  \"ru\",\n  \"sv\",\n  \"tr\",\n  \"vi\"\n];\n\nconst stopwords = require(\"./stopwords/stopwords\");\n\nfunction extract(\n  str,\n  options = {\n    remove_digits: true,\n    return_changed_case: true,\n  }\n) {\n  if (!str) {\n    return [];\n  }\n\n  const return_changed_case = options.return_changed_case;\n  const return_chained_words = options.return_chained_words;\n  const remove_digits = options.remove_digits;\n  let _language = options.language || \"en\";\n  const _remove_duplicates = options.remove_duplicates || false;\n  const return_max_ngrams = options.return_max_ngrams;\n\n  _language = sanitize_language(_language);\n\n  //  strip any HTML and trim whitespace\n  const text = str.replace(/(<([^>]+)>)/gi, \"\").trim();\n  if (!text) {\n    return [];\n  } else {\n    const words = text.split(/\\s/);\n    const unchanged_words = [];\n    const low_words = [];\n    //  change the case of all the words\n    for (let x = 0; x < words.length; x++) {\n      let w = words[x].match(/https?:\\/\\/.*[\\r\\n]*/g)\n        ? words[x]\n        : words[x].replace(/\\.|,|;|!|\\?|\\(|\\)|:|\"|^'|'$|“|”|‘|’/g, \"\");\n      //  remove periods, question marks, exclamation points, commas, and semi-colons\n      //  if this is a short result, make sure it's not a single character or something 'odd'\n      if (w.length === 1) {\n        w = w.replace(/_|@|&|#/g, \"\");\n      }\n      //  if it's a number, remove it\n      const digits_match = w.match(/\\d/g);\n      if (remove_digits && digits_match && digits_match.length === w.length) {\n        w = \"\";\n      }\n      if (w.length > 0) {\n        low_words.push(w.toLowerCase());\n        unchanged_words.push(w);\n      }\n    }\n    let results = [];\n    const _stopwords =\n      options.stopwords || getStopwords({ language: _language });\n    let _last_result_word_index = 0;\n    let _start_result_word_index = 0;\n    let _unbroken_word_chain = false;\n    for (let y = 0; y < low_words.length; y++) {\n      if (_stopwords.indexOf(low_words[y]) < 0) {\n        if (_last_result_word_index !== y - 1) {\n          _start_result_word_index = y;\n          _unbroken_word_chain = false;\n        } else {\n          _unbroken_word_chain = true;\n        }\n        const result_word =\n          return_changed_case &&\n            !unchanged_words[y].match(/https?:\\/\\/.*[\\r\\n]*/g)\n            ? low_words[y]\n            : unchanged_words[y];\n\n        if (\n          return_max_ngrams &&\n          _unbroken_word_chain &&\n          !return_chained_words &&\n          return_max_ngrams > y - _start_result_word_index &&\n          _last_result_word_index === y - 1\n        ) {\n          const change_pos = results.length - 1 < 0 ? 0 : results.length - 1;\n          results[change_pos] = results[change_pos]\n            ? results[change_pos] + \" \" + result_word\n            : result_word;\n        } else if (return_chained_words && _last_result_word_index === y - 1) {\n          const change_pos = results.length - 1 < 0 ? 0 : results.length - 1;\n          results[change_pos] = results[change_pos]\n            ? results[change_pos] + \" \" + result_word\n            : result_word;\n        } else {\n          results.push(result_word);\n        }\n\n        _last_result_word_index = y;\n      } else {\n        _unbroken_word_chain = false;\n      }\n    }\n\n    if (_remove_duplicates) {\n      results = results.filter((v, i, a) => a.indexOf(v) === i);;\n    }\n\n    return results;\n  }\n}\n\nfunction getStopwords(options) {\n  options = options || {};\n\n  let _language = options.language || \"en\";\n  _language = sanitize_language(_language);\n\n  return stopwords[_language];\n}\n\n// Sanitize requested language\nfunction sanitize_language(requested_language) {\n  const error_message = \"Language must be one of [\" +\n    supported_language_codes.join(\", \") + \"]\";\n\n  if (typeof requested_language !== \"string\") {\n    throw new Error(error_message);\n  }\n\n  // Fallback for old language option format\n  const _requested_language = (requested_language.length === 2) ?\n    requested_language :\n    get_language_mapping(requested_language);\n\n  if (supported_language_codes.indexOf(_requested_language) < 0) {\n    throw new Error(error_message);\n  }\n\n  return _requested_language;\n}\n\n// Support old language option format by mapping to ISO 639-1 codes\nfunction get_language_mapping(requested_language) {\n  if (typeof requested_language !== \"string\") {\n    return \"\";\n  }\n\n  const mapping = {\n    arabic: \"ar\",\n    czech: \"cs\",\n    danish: \"da\",\n    dutch: \"nl\",\n    english: \"en\",\n    french: \"fr\",\n    galician: \"gl\",\n    german: \"de\",\n    italian: \"it\",\n    korean: \"ko\",\n    persian: \"fa\",\n    polish: \"pl\",\n    portuguese: \"pt\",\n    romanian: \"ro\",\n    russian: \"ru\",\n    spanish: \"es\",\n    swedish: \"sv\",\n    turkish: \"tr\",\n    vietnam: \"vt\"\n  };\n\n  return mapping[requested_language] || \"\";\n}\n\nmodule.exports = {\n  getStopwords,\n  extract,\n  supported_language_codes\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}