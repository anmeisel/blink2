{"ast":null,"code":"import Glossary from './Glossary';\nlet glossary1 = new Glossary(0, \"React\", [\"First answer\", \"Second answer\", \"Third answer\"], \"JavaScript framework that works with JSX files.\", false);\nlet glossary2 = new Glossary(1, \"JSX\", [\"First answer\", \"Second answer\", \"Third answer\"], \"HTML + JavaScript. Server-side scripting. Functions can be returned in pure HTML.\", false);\nlet glossary3 = new Glossary(2, \"XML\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Extensible Markup Language. XML was designed to carry data - with focus on what data is. Does not display data.\", false);\nlet glossary4 = new Glossary(3, \"To start a project...\", [\"First answer\", \"Second answer\", \"Third answer\"], \"npx create-react-app [name of project]\", false);\nlet glossary5 = new Glossary(4, \"Component\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Reusable functions. React only re-renders components that have changed. State is like a variable.\", false);\nlet glossary6 = new Glossary(5, \"useState\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Re-renders once the function has been manipulated. It’s a React hook - functional compenet that tracks its own data. It takes a reference to the value (variable - but don't refer to this variable in the function), and then a function name. UseState will start at whatever is in its parameter. UseState is how we use a function to a component instead of a class. E.g.: const [count, setCount] = useState(0). A state variable should always be declared at the highest level its needed.\", false);\nlet glossary7 = new Glossary(6, \"Hooks\", [\"First answer\", \"Second answer\", \"Third answer\"], \"functional components as opposed to class components. Functional component is a reusable, imported. A function that returns some HTML.\", false);\nlet glossary8 = new Glossary(7, \"Props\", [\"First answer\", \"Second answer\", \"Third answer\"], \"A generic parameter passed via the function. Object full of properties that we can assign. For example, you can give props to a component and assign them in the component name in app.js.\", false);\nlet glossary9 = new Glossary(8, \"OnChange\", [\"First answer\", \"Second answer\", \"Third answer\"], \"This will always give you an event object. Every onChange passes an event object, containing info about the event.\", false);\nlet glossary10 = new Glossary(9, \"Callback function\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Parent (app.js) passes a State function as props to a child element (colourbutton.js). The child gets State of parent. This function or state can be a prop. Steps for making a prop: 1. Make a custom prop in your app.js component name i.e. <ColourButton col={'green'}/>. 2. Bring prop as an attribute in the component function name i.e. ColourButton(props). 3. Use it inside your component i.e. style={{backgroundColor: props.col}}. All inline!\", false);\nlet glossary11 = new Glossary(10, \"Toggle\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Make a useState(false). Underneath make a toggleClass function (i.e. const toggleClass = () => {setBackground(!background)}). In the button inline make a ternary operator (i.e. style={{ backgroundColor: background ? 'darkslateblue' : 'green' }} ).\", false);\nlet glossary12 = new Glossary(11, \"Map\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Like a For loop. Applies a function to an array and returns a new array. Make sure to always put a key right inside the return statement when calling the component.\", false);\nlet glossary13 = new Glossary(12, \"Flex\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Flex will always affect the child elements. Full flex is 1. 50% will be 0.5.\", false);\nlet glossaryArray = [glossary1, glossary2, glossary3, glossary4, glossary5, glossary6, glossary7, glossary8, glossary9, glossary10, glossary11, glossary12, glossary13];\nexport default glossaryArray;","map":{"version":3,"names":["Glossary","glossary1","glossary2","glossary3","glossary4","glossary5","glossary6","glossary7","glossary8","glossary9","glossary10","glossary11","glossary12","glossary13","glossaryArray"],"sources":["/Users/anameisel/Documents/personal/learning/iungo/Software-Engineering/week-6/244001_glossary/src/model/GlossaryArray.js"],"sourcesContent":["import Glossary from './Glossary'\n\nlet glossary1 = new Glossary(0, \"React\", [\"First answer\", \"Second answer\", \"Third answer\"], \"JavaScript framework that works with JSX files.\", false)\nlet glossary2 = new Glossary(1, \"JSX\", [\"First answer\", \"Second answer\", \"Third answer\"], \"HTML + JavaScript. Server-side scripting. Functions can be returned in pure HTML.\", false)\nlet glossary3 = new Glossary(2, \"XML\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Extensible Markup Language. XML was designed to carry data - with focus on what data is. Does not display data.\", false)\nlet glossary4 = new Glossary(3, \"To start a project...\", [\"First answer\", \"Second answer\", \"Third answer\"], \"npx create-react-app [name of project]\", false)\nlet glossary5 = new Glossary(4, \"Component\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Reusable functions. React only re-renders components that have changed. State is like a variable.\", false)\nlet glossary6 = new Glossary(5, \"useState\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Re-renders once the function has been manipulated. It’s a React hook - functional compenet that tracks its own data. It takes a reference to the value (variable - but don't refer to this variable in the function), and then a function name. UseState will start at whatever is in its parameter. UseState is how we use a function to a component instead of a class. E.g.: const [count, setCount] = useState(0). A state variable should always be declared at the highest level its needed.\", false)\nlet glossary7 = new Glossary(6, \"Hooks\", [\"First answer\", \"Second answer\", \"Third answer\"], \"functional components as opposed to class components. Functional component is a reusable, imported. A function that returns some HTML.\", false)\nlet glossary8 = new Glossary(7, \"Props\", [\"First answer\", \"Second answer\", \"Third answer\"], \"A generic parameter passed via the function. Object full of properties that we can assign. For example, you can give props to a component and assign them in the component name in app.js.\", false)\nlet glossary9 = new Glossary(8, \"OnChange\", [\"First answer\", \"Second answer\", \"Third answer\"], \"This will always give you an event object. Every onChange passes an event object, containing info about the event.\", false)\nlet glossary10 = new Glossary(9, \"Callback function\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Parent (app.js) passes a State function as props to a child element (colourbutton.js). The child gets State of parent. This function or state can be a prop. Steps for making a prop: 1. Make a custom prop in your app.js component name i.e. <ColourButton col={'green'}/>. 2. Bring prop as an attribute in the component function name i.e. ColourButton(props). 3. Use it inside your component i.e. style={{backgroundColor: props.col}}. All inline!\", false)\nlet glossary11 = new Glossary(10, \"Toggle\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Make a useState(false). Underneath make a toggleClass function (i.e. const toggleClass = () => {setBackground(!background)}). In the button inline make a ternary operator (i.e. style={{ backgroundColor: background ? 'darkslateblue' : 'green' }} ).\", false)\nlet glossary12 = new Glossary(11, \"Map\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Like a For loop. Applies a function to an array and returns a new array. Make sure to always put a key right inside the return statement when calling the component.\", false)\nlet glossary13 = new Glossary(12, \"Flex\", [\"First answer\", \"Second answer\", \"Third answer\"], \"Flex will always affect the child elements. Full flex is 1. 50% will be 0.5.\", false)\n\nlet glossaryArray = [glossary1, glossary2, glossary3, glossary4, glossary5, glossary6, glossary7, glossary8, glossary9, glossary10, glossary11, glossary12, glossary13]\n\nexport default glossaryArray"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,YAAY;AAEjC,IAAIC,SAAS,GAAG,IAAID,QAAQ,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,iDAAiD,EAAE,KAAK,CAAC;AACrJ,IAAIE,SAAS,GAAG,IAAIF,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,mFAAmF,EAAE,KAAK,CAAC;AACrL,IAAIG,SAAS,GAAG,IAAIH,QAAQ,CAAC,CAAC,EAAE,KAAK,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,iHAAiH,EAAE,KAAK,CAAC;AACnN,IAAII,SAAS,GAAG,IAAIJ,QAAQ,CAAC,CAAC,EAAE,uBAAuB,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,wCAAwC,EAAE,KAAK,CAAC;AAC5J,IAAIK,SAAS,GAAG,IAAIL,QAAQ,CAAC,CAAC,EAAE,WAAW,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,mGAAmG,EAAE,KAAK,CAAC;AAC3M,IAAIM,SAAS,GAAG,IAAIN,QAAQ,CAAC,CAAC,EAAE,UAAU,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,oeAAoe,EAAE,KAAK,CAAC;AAC3kB,IAAIO,SAAS,GAAG,IAAIP,QAAQ,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,wIAAwI,EAAE,KAAK,CAAC;AAC5O,IAAIQ,SAAS,GAAG,IAAIR,QAAQ,CAAC,CAAC,EAAE,OAAO,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,4LAA4L,EAAE,KAAK,CAAC;AAChS,IAAIS,SAAS,GAAG,IAAIT,QAAQ,CAAC,CAAC,EAAE,UAAU,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,oHAAoH,EAAE,KAAK,CAAC;AAC3N,IAAIU,UAAU,GAAG,IAAIV,QAAQ,CAAC,CAAC,EAAE,mBAAmB,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,6bAA6b,EAAE,KAAK,CAAC;AAC9iB,IAAIW,UAAU,GAAG,IAAIX,QAAQ,CAAC,EAAE,EAAE,QAAQ,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,yPAAyP,EAAE,KAAK,CAAC;AAChW,IAAIY,UAAU,GAAG,IAAIZ,QAAQ,CAAC,EAAE,EAAE,KAAK,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,sKAAsK,EAAE,KAAK,CAAC;AAC1Q,IAAIa,UAAU,GAAG,IAAIb,QAAQ,CAAC,EAAE,EAAE,MAAM,EAAE,CAAC,cAAc,EAAE,eAAe,EAAE,cAAc,CAAC,EAAE,8EAA8E,EAAE,KAAK,CAAC;AAEnL,IAAIc,aAAa,GAAG,CAACb,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,SAAS,EAAEC,UAAU,EAAEC,UAAU,EAAEC,UAAU,EAAEC,UAAU,CAAC;AAEvK,eAAeC,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}